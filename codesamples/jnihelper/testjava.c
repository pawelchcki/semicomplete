#include <jni.h>
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>

#define PATH_SEPARATOR ":"
#define USER_CLASSPATH "." 

/* Override libc's abort() with our own, then try to call libc's abort.
 * Generated by liboverride (http://semicomplete.com/projects/liboverride/)
 */
void abort() {
  void *handle = NULL;
  //This will turn the function proto into a function pointer declaration
  void (*real_func)() = NULL;
  const char library[] = "/lib/libc.so.6";
  handle = dlopen(library, RTLD_LAZY);

  if (handle == NULL) {
    fprintf(stderr, "Failed to dlopen %s\n", library);
    fprintf(stderr, "dlerror says: %s\n", dlerror());
    return;
  }
  real_func = dlsym(handle, "abort");

  {
    printf("aborting!\n");
  }

  real_func();
}

/**
 * Much of this taken from the java JNI guide.
 * http://java.sun.com/docs/books/jni/html/invoke.html
 */

int main(int argc, char **argv) {
  JNIEnv *env;
  JavaVM *jvm;
  jint res;
  jclass cls;
  jmethodID method_id;
  jstring jstr;
  jclass stringClass;
  jobjectArray args;

  JavaVMInitArgs vm_args; 
  JavaVMOption *options;
  options = calloc(argc - 1, sizeof(JavaVMOption));
  int i = 0;
  for (i = 1 ; i < argc; i++) {
    options[i - 1].optionString = argv[i];
  }
  vm_args.version = JNI_VERSION_1_2;
  vm_args.options = options;
  vm_args.nOptions = argc - 1;
  vm_args.ignoreUnrecognized = JNI_TRUE;

  JNI_GetDefaultJavaVMInitArgs(&vm_args); 
  res = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);
  if (res < 0) { 
    fprintf(stderr, "Failed creating Java VM\n");
    return 1;
  }

  cls = (*env)->FindClass(env, argv[argc - 1]);
  if (cls == NULL) {
    fprintf(stderr, "Cound not find class: %s\n", argv[argc - 1]);
    goto destroy;
  }

  method_id = (*env)->GetStaticMethodID(env, cls, "main", "([Ljava/lang/String;)V");
  if (method_id == NULL) {
    fprintf(stderr, "Cound not find public static method 'main' in class: %s\n", argv[argc - 1]);
    goto destroy;
  }


  destroy:
  (*jvm)->DestroyJavaVM(jvm);
}

